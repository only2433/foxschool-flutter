// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'VocabularyDataResult.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

VocabularyDataResult _$VocabularyDataResultFromJson(Map<String, dynamic> json) {
  return _VocabularyDataResult.fromJson(json);
}

/// @nodoc
mixin _$VocabularyDataResult {
  @JsonKey(name: 'content_id')
  String get contentID => throw _privateConstructorUsedError;
  @JsonKey(name: 'id')
  String get vocabularyID => throw _privateConstructorUsedError;
  @JsonKey(name: 'text')
  String get wordText => throw _privateConstructorUsedError;
  @JsonKey(name: 'mean')
  String get meanText => throw _privateConstructorUsedError;
  @JsonKey(name: 'example')
  String get exampleText => throw _privateConstructorUsedError;
  @JsonKey(name: 'sound_url')
  String get soundUrl => throw _privateConstructorUsedError;
  int get lineCount => throw _privateConstructorUsedError;
  bool get isSelected => throw _privateConstructorUsedError;
  bool get isPlaying => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $VocabularyDataResultCopyWith<VocabularyDataResult> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VocabularyDataResultCopyWith<$Res> {
  factory $VocabularyDataResultCopyWith(VocabularyDataResult value,
          $Res Function(VocabularyDataResult) then) =
      _$VocabularyDataResultCopyWithImpl<$Res, VocabularyDataResult>;
  @useResult
  $Res call(
      {@JsonKey(name: 'content_id') String contentID,
      @JsonKey(name: 'id') String vocabularyID,
      @JsonKey(name: 'text') String wordText,
      @JsonKey(name: 'mean') String meanText,
      @JsonKey(name: 'example') String exampleText,
      @JsonKey(name: 'sound_url') String soundUrl,
      int lineCount,
      bool isSelected,
      bool isPlaying});
}

/// @nodoc
class _$VocabularyDataResultCopyWithImpl<$Res,
        $Val extends VocabularyDataResult>
    implements $VocabularyDataResultCopyWith<$Res> {
  _$VocabularyDataResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? contentID = null,
    Object? vocabularyID = null,
    Object? wordText = null,
    Object? meanText = null,
    Object? exampleText = null,
    Object? soundUrl = null,
    Object? lineCount = null,
    Object? isSelected = null,
    Object? isPlaying = null,
  }) {
    return _then(_value.copyWith(
      contentID: null == contentID
          ? _value.contentID
          : contentID // ignore: cast_nullable_to_non_nullable
              as String,
      vocabularyID: null == vocabularyID
          ? _value.vocabularyID
          : vocabularyID // ignore: cast_nullable_to_non_nullable
              as String,
      wordText: null == wordText
          ? _value.wordText
          : wordText // ignore: cast_nullable_to_non_nullable
              as String,
      meanText: null == meanText
          ? _value.meanText
          : meanText // ignore: cast_nullable_to_non_nullable
              as String,
      exampleText: null == exampleText
          ? _value.exampleText
          : exampleText // ignore: cast_nullable_to_non_nullable
              as String,
      soundUrl: null == soundUrl
          ? _value.soundUrl
          : soundUrl // ignore: cast_nullable_to_non_nullable
              as String,
      lineCount: null == lineCount
          ? _value.lineCount
          : lineCount // ignore: cast_nullable_to_non_nullable
              as int,
      isSelected: null == isSelected
          ? _value.isSelected
          : isSelected // ignore: cast_nullable_to_non_nullable
              as bool,
      isPlaying: null == isPlaying
          ? _value.isPlaying
          : isPlaying // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$VocabularyDataResultImplCopyWith<$Res>
    implements $VocabularyDataResultCopyWith<$Res> {
  factory _$$VocabularyDataResultImplCopyWith(_$VocabularyDataResultImpl value,
          $Res Function(_$VocabularyDataResultImpl) then) =
      __$$VocabularyDataResultImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'content_id') String contentID,
      @JsonKey(name: 'id') String vocabularyID,
      @JsonKey(name: 'text') String wordText,
      @JsonKey(name: 'mean') String meanText,
      @JsonKey(name: 'example') String exampleText,
      @JsonKey(name: 'sound_url') String soundUrl,
      int lineCount,
      bool isSelected,
      bool isPlaying});
}

/// @nodoc
class __$$VocabularyDataResultImplCopyWithImpl<$Res>
    extends _$VocabularyDataResultCopyWithImpl<$Res, _$VocabularyDataResultImpl>
    implements _$$VocabularyDataResultImplCopyWith<$Res> {
  __$$VocabularyDataResultImplCopyWithImpl(_$VocabularyDataResultImpl _value,
      $Res Function(_$VocabularyDataResultImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? contentID = null,
    Object? vocabularyID = null,
    Object? wordText = null,
    Object? meanText = null,
    Object? exampleText = null,
    Object? soundUrl = null,
    Object? lineCount = null,
    Object? isSelected = null,
    Object? isPlaying = null,
  }) {
    return _then(_$VocabularyDataResultImpl(
      contentID: null == contentID
          ? _value.contentID
          : contentID // ignore: cast_nullable_to_non_nullable
              as String,
      vocabularyID: null == vocabularyID
          ? _value.vocabularyID
          : vocabularyID // ignore: cast_nullable_to_non_nullable
              as String,
      wordText: null == wordText
          ? _value.wordText
          : wordText // ignore: cast_nullable_to_non_nullable
              as String,
      meanText: null == meanText
          ? _value.meanText
          : meanText // ignore: cast_nullable_to_non_nullable
              as String,
      exampleText: null == exampleText
          ? _value.exampleText
          : exampleText // ignore: cast_nullable_to_non_nullable
              as String,
      soundUrl: null == soundUrl
          ? _value.soundUrl
          : soundUrl // ignore: cast_nullable_to_non_nullable
              as String,
      lineCount: null == lineCount
          ? _value.lineCount
          : lineCount // ignore: cast_nullable_to_non_nullable
              as int,
      isSelected: null == isSelected
          ? _value.isSelected
          : isSelected // ignore: cast_nullable_to_non_nullable
              as bool,
      isPlaying: null == isPlaying
          ? _value.isPlaying
          : isPlaying // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VocabularyDataResultImpl extends _VocabularyDataResult {
  _$VocabularyDataResultImpl(
      {@JsonKey(name: 'content_id') this.contentID = "",
      @JsonKey(name: 'id') this.vocabularyID = "",
      @JsonKey(name: 'text') this.wordText = "",
      @JsonKey(name: 'mean') this.meanText = "",
      @JsonKey(name: 'example') this.exampleText = "",
      @JsonKey(name: 'sound_url') this.soundUrl = "",
      this.lineCount = 0,
      this.isSelected = false,
      this.isPlaying = false})
      : super._();

  factory _$VocabularyDataResultImpl.fromJson(Map<String, dynamic> json) =>
      _$$VocabularyDataResultImplFromJson(json);

  @override
  @JsonKey(name: 'content_id')
  final String contentID;
  @override
  @JsonKey(name: 'id')
  final String vocabularyID;
  @override
  @JsonKey(name: 'text')
  final String wordText;
  @override
  @JsonKey(name: 'mean')
  final String meanText;
  @override
  @JsonKey(name: 'example')
  final String exampleText;
  @override
  @JsonKey(name: 'sound_url')
  final String soundUrl;
  @override
  @JsonKey()
  final int lineCount;
  @override
  @JsonKey()
  final bool isSelected;
  @override
  @JsonKey()
  final bool isPlaying;

  @override
  String toString() {
    return 'VocabularyDataResult(contentID: $contentID, vocabularyID: $vocabularyID, wordText: $wordText, meanText: $meanText, exampleText: $exampleText, soundUrl: $soundUrl, lineCount: $lineCount, isSelected: $isSelected, isPlaying: $isPlaying)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VocabularyDataResultImpl &&
            (identical(other.contentID, contentID) ||
                other.contentID == contentID) &&
            (identical(other.vocabularyID, vocabularyID) ||
                other.vocabularyID == vocabularyID) &&
            (identical(other.wordText, wordText) ||
                other.wordText == wordText) &&
            (identical(other.meanText, meanText) ||
                other.meanText == meanText) &&
            (identical(other.exampleText, exampleText) ||
                other.exampleText == exampleText) &&
            (identical(other.soundUrl, soundUrl) ||
                other.soundUrl == soundUrl) &&
            (identical(other.lineCount, lineCount) ||
                other.lineCount == lineCount) &&
            (identical(other.isSelected, isSelected) ||
                other.isSelected == isSelected) &&
            (identical(other.isPlaying, isPlaying) ||
                other.isPlaying == isPlaying));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      contentID,
      vocabularyID,
      wordText,
      meanText,
      exampleText,
      soundUrl,
      lineCount,
      isSelected,
      isPlaying);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$VocabularyDataResultImplCopyWith<_$VocabularyDataResultImpl>
      get copyWith =>
          __$$VocabularyDataResultImplCopyWithImpl<_$VocabularyDataResultImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$VocabularyDataResultImplToJson(
      this,
    );
  }
}

abstract class _VocabularyDataResult extends VocabularyDataResult {
  factory _VocabularyDataResult(
      {@JsonKey(name: 'content_id') final String contentID,
      @JsonKey(name: 'id') final String vocabularyID,
      @JsonKey(name: 'text') final String wordText,
      @JsonKey(name: 'mean') final String meanText,
      @JsonKey(name: 'example') final String exampleText,
      @JsonKey(name: 'sound_url') final String soundUrl,
      final int lineCount,
      final bool isSelected,
      final bool isPlaying}) = _$VocabularyDataResultImpl;
  _VocabularyDataResult._() : super._();

  factory _VocabularyDataResult.fromJson(Map<String, dynamic> json) =
      _$VocabularyDataResultImpl.fromJson;

  @override
  @JsonKey(name: 'content_id')
  String get contentID;
  @override
  @JsonKey(name: 'id')
  String get vocabularyID;
  @override
  @JsonKey(name: 'text')
  String get wordText;
  @override
  @JsonKey(name: 'mean')
  String get meanText;
  @override
  @JsonKey(name: 'example')
  String get exampleText;
  @override
  @JsonKey(name: 'sound_url')
  String get soundUrl;
  @override
  int get lineCount;
  @override
  bool get isSelected;
  @override
  bool get isPlaying;
  @override
  @JsonKey(ignore: true)
  _$$VocabularyDataResultImplCopyWith<_$VocabularyDataResultImpl>
      get copyWith => throw _privateConstructorUsedError;
}
